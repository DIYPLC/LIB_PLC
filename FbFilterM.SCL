//БЛОК В РАЗРАБОТКЕ НЕ ИСПОЛЬЗОВАТЬ!!!
FUNCTION_BLOCK FbFilterM //Фильтр медианный.

//       DbFilterM
//    +-------------+
//    |  FbFilterM  |
// ->-|In        Out|->-
//   -|Size         |
//   -|Ts_in        |
//   -|Ts_ms        |
//   -|Reset        |
//    +-------------+

//Атрибуты для STEP7.
TITLE   = 'Фильтр медианный.'
VERSION : '0.1'
AUTHOR  : 'VA'
FAMILY  : 'LibPlc'
{//Атрибуты для PCS7.
S7_read_back := 'true' ; //CFC: Chart>Readback активен для прототипов DB.
S7_blockview := 'big'    //CFC: отображение блока маленькое или большое.
}

VAR_INPUT //Входные переменные, сохраняемые.
In    :REAL := 0.0  ; //Входной сигнал до фильтрации.
Size  :INT  := 10   ; //Размер массива для сортировки (Количество выборок).
Ts_in :DINT := 2000 ; //Время между выборками и сортировками для входа In [мс].
Ts_ms :DINT := 100  ; //Шаг дискретизации по времени [мс].
Reset :BOOL := FALSE; //Сброс при перезагрузке.
END_VAR

VAR_OUTPUT //Выходные переменные, сохраняемые.
Out :REAL := 0.0; //Выходной сигнал (середина отсортированного массива).
END_VAR

VAR //Внутренние переменные, сохраняемые.
TimerTs     :DINT := 0    ; //Таймер для ресемплинга [мс].
FlagRunCode :BOOL := FALSE; //Флаг выполнить программу с шагом дискретизации Ts_in.
Size_prev   :INT  := 0    ; //Предидущее значение соответствующего входного параметра.
Ts_in_prev  :DINT := 0    ; //Предидущее значение соответствующего входного параметра.
i           :INT  := 0    ; //Счетчик цикла.
Old_i       :INT  := 0    ; //Адрес самого старого элемента в массиве.
FlagSortUp  :BOOL := FALSE; //Флаг 1=сортировка вверх 0=сортировка вниз.
InputArray  :ARRAY [0..16] OF REAL; //Массив входных значений для сортировки.
TimeArray   :ARRAY [0..16] OF INT ; //Массив времени жизни элемента 0-самый молодой 1-старше 2- еще старше.
END_VAR

VAR_TEMP  //Временные переменные, не сохраняемые.
TempValue :REAL; //Временная переменная для сортировки значений.
TempTime  :INT ; //Временная переменная для сортировки времени жизни элемента.
END_VAR

//Защита от выхода массива за границы.
//Максимальное число должно повторять размер массива.
IF (Size >= 16) THEN
Size := 16;
END_IF;
//Менее 5 элементов не вижу смысла
IF (Size <= 5) THEN
Size := 5;
END_IF;

//Ресэмплинг выключен если Ts_ms >= Ts_in
IF (Ts_ms >= Ts_in) THEN
TimerTs := 0;
FlagRunCode := TRUE;
ELSE
  //Ресэмплинг для возможности изменения времени между выборками.
  IF (TimerTs >= Ts_in) THEN
  TimerTs := 0;
  FlagRunCode := TRUE;
  ELSE
  TimerTs := TimerTs + Ts_ms;
  FlagRunCode := FALSE;
  END_IF;
END_IF;

//****************************************************************************
//Инициализация массива.
//При перезапуске ПЛК.
//При изменении настроек фильтра.
IF (Reset OR (Size <> Size_prev) OR (Ts_in <> Ts_in_prev)) THEN
  //Цикл от 0 до Size включительно с шагом +1.
  FOR i := 0 TO Size BY 1 DO
    //Заполняем весь массив значений входным сигналом.
    InputArray[i] := In;
    //Заполняем массив времени жизни элемента.
    TimeArray[i] := i;
  END_FOR;
//После инициализации самый старый элемент вверху массива.
Old_i := Size;
// Массив после инициализации при In = 0.0, Size = 4.
//  InputArray TimeArray  i
// +----------+---------+---+
// |    0.0   |    4    | 4 | <- Old_i
// |    0.0   |    3    | 3 |
// |    0.0   |    2    | 2 |
// |    0.0   |    1    | 1 |
// |    0.0   |    0    | 0 |
// +----------+---------+---+
// Направление работы цикла от 0 до 4.
END_IF;

//Код выполняемый с шагом дискретизации Ts_in.
IF (FlagRunCode) THEN

//****************************************************************************

  FOR i := 0 TO Size BY 1 DO
    //Обновляем массив возраста элементов.    
    IF (TimeArray[i] = Size) THEN
      //Самый старый элемент становится самым новым
      TimeArray[i] := 0;
    ELSE
      //Все остальные стареют на +1.
      TimeArray[i] := TimeArray[i] + 1;
      //Ищем самый старый элемент массива.
      IF (TimeArray[i] = Size) THEN
        //Запоминаем самый старый элемент массива
        //В него потом запишем новое значение входа
        Old_i := i;
      END_IF;
    END_IF;
  END_FOR;

//****************************************************************************

//Записываем новое значение входа в самый стырый элемент массива.
InputArray[Old_i] := In;

//****************************************************************************

//Весь массив сортировать нет смысла.
//Надо отсортировать по возростанию лишь одно значение InputArray[Old_i]
//Все остальный значения отсортированны ранее.
//Определим надо сортировать "пузырек" или "камешек".
IF (Old_i = 0) THEN
//  InputArray TimeArray  i
// +----------+---------+---+
// |    5.0   |    3    | 4 |
// |    4.0   |    2    | 3 |
// |    3.0   |    1    | 2 |
// |    2.0   |    0    | 1 |
// |    1.0   |    4    | 0 | <- Old_i
// +----------+---------+---+
//Допустим новое значение прилетело в низ массива.
//Делаем вывод сортировать "пузырек" или "камешек".
  IF (InputArray[0] >= InputArray[1]) THEN
  //Пузырек всплывает
  FlagSortUp := TRUE;
  ELSE
  //Камень тонет
  FlagSortUp := FALSE;
  END_IF;
ELSE

//  InputArray TimeArray  i
// +----------+---------+---+
// |    5.0   |    4    | 4 | <- Old_i
// |    4.0   |    3    | 3 | <- Old_i
// |    3.0   |    2    | 2 | <- Old_i
// |    2.0   |    1    | 1 | <- Old_i
// |    1.0   |    0    | 0 |
// +----------+---------+---+
//Иначе новое значение прилетело в верх массива.
//Делаем вывод сортировать "пузырек" или "камешек".
  IF (InputArray[Old_i - 1] >= InputArray[Old_i]) THEN
  //Пузырек всплывает
  FlagSortUp := TRUE;
  ELSE
  //Камень тонет
  FlagSortUp := FALSE;
  END_IF;
END_IF;

//****************************************************************************

IF (FlagSortUp) THEN
//  InputArray TimeArray  i
// +----------+---------+---+
// |    3.0   |    4    | 4 | 
// |    3.0   |    3    | 3 | <- Size - 1
// |    3.0   |    2    | 2 | 
// |    1.0   |    1    | 1 | 
// |    2.0   |    0    | 0 | <-
// +----------+---------+---+
//Можно сделать только 1 полный проход по всему массиву
//Так как не отсортированно только одно новое значение
//Так дольше но количество циклов всегда одинаковое.
//Пузырек большое число и сортируем его ввверх
//Получаем сортированный по возрастанию список
  FOR i := 0 TO (Size - 1) BY 1 DO
    IF (InputArray[i] > InputArray[i + 1]) THEN
      //Если нижнее значение больше верхнего то
      //Меняем местами нижнее и верхнее.
      TempValue := InputArray[i + 1];
      InputArray[i + 1] := InputArray[i];
      InputArray[i] := TempValue;
      //Массив времени связан с массивом значений.
      TempTime := TimeArray[i + 1];
      TimeArray[i + 1] := TimeArray[i];
      TimeArray[i] := TempTime;
    END_IF;
  END_FOR;
ELSE
//  InputArray TimeArray  i
// +----------+---------+---+
// |    2.0   |    1    | 4 | <- Size
// |    3.0   |    0    | 3 | 
// |    1.0   |    4    | 2 | 
// |    1.0   |    3    | 1 | <-
// |    1.0   |    2    | 0 | 
// +----------+---------+---+
//Можно сделать только 1 полный проход по всему массиву
//Так как не отсортированно только одно новое значение
//Так дольше но количество циклов всегда одинаковое.
//Маленькое число и сортируем его вниз
//Получаем сортированный по возрастанию список
  FOR i := Size TO 1 BY -1 DO
    IF (InputArray[i] < InputArray[i - 1]) THEN
      //Если нижнее значение больше верхнего то
      //Меняем местами нижнее и верхнее.
      TempValue := InputArray[i - 1];
      InputArray[i - 1] := InputArray[i];
      InputArray[i] := TempValue;
      //Массив времени связан с массивом значений.
      TempTime := TimeArray[i - 1];
      TimeArray[i - 1] := TimeArray[i];
      TimeArray[i] := TempTime;
    END_IF;
  END_FOR;
END_IF; //IF (FlagSortUp) THEN

END_IF; //IF (FlagRunCode) THEN

//****************************************************************************

//  InputArray TimeArray  i
// +----------+---------+---+
// |    3.0   |    0    | 4 | <- Size
// |    2.0   |    1    | 3 |
// |    1.0   |    4    | 2 | <- Size / 2
// |    1.0   |    3    | 1 |
// |    1.0   |    2    | 0 |
// +----------+---------+---+
//Выход это середина отсортированного массива.
Out := InputArray[Size / 2];

//****************************************************************************

//Запомнить предидущее значение настроек фильтра.
Size_prev  := Size ; //Предидущее значение соответствующего входного параметра.
Ts_in_prev := Ts_in; //Предидущее значение соответствующего входного параметра.

END_FUNCTION_BLOCK

//  +---------+
//  | GNU GPL |
//  +---------+
//  |
//  |
//  .= .-_-. =.
// ((_/)o o(\_))
//  `-'(. .)`-'
//  |/| \_/ |\
//  ( |     | )
//  /"\_____/"\
//  \__)   (__/
// @COPYLEFT ALL WRONGS RESERVED :)
// Author: VA
// Contacts: DIY.PLC.314@gmail.com
// License: GNU GPL v2

