FUNCTION_BLOCK "Fb2oo3"
TITLE = 'Резервирование датчиков методом голосования.'

{ S7_read_back := 'true' ;
  S7_blockview := 'big'  }

AUTHOR  : VA
FAMILY  : LIB_PLC
VERSION : '2.0'

VAR_INPUT // Входные переменные, сохраняемые.
In1    :REAL := 0.0  ; // Датчик 1.
In2    :REAL := 0.0  ; // Датчик 2.
In3    :REAL := 0.0  ; // Датчик 3.
ErIn1  :BOOL := FALSE; // Датчик 1 ошибка.
ErIn2  :BOOL := FALSE; // Датчик 2 ошибка.
ErIn3  :BOOL := FALSE; // Датчик 3 ошибка.
DifMax :REAL := 5.0  ; // Максимальное рассогласования входов.
LimMax :REAL := 99.9 ; // Максимальное значение входов.
LimMin :REAL := 0.1  ; // Минимальное значение входов.
ValEr  :REAL := 0.0  ; // Значение выхода если все датчики неисправны.
END_VAR

VAR_OUTPUT // Выходные переменные, сохраняемые.
Out   :REAL := 0.0  ; // Выход.
ErOut :BOOL := FALSE; // Ошибка все датчики неисправны.
Er1   :BOOL := FALSE; // Ошибка датчика 1.
Er2   :BOOL := FALSE; // Ошибка датчика 2.
Er3   :BOOL := FALSE; // Ошибка датчика 3.
END_VAR

VAR // Внутренние переменные, сохраняемые.
State  :INT  := 0    ; // Режим работы 0=2oo3 1,2,4=1оо2 3,5,6=1оо1 7=ERROR
Er1Max :BOOL := FALSE; // Ошибка датчика 1 по максимальному значению.
Er2Max :BOOL := FALSE; // Ошибка датчика 2 по максимальному значению.
Er3Max :BOOL := FALSE; // Ошибка датчика 3 по максимальному значению.
Er1Min :BOOL := FALSE; // Ошибка датчика 1 по минимальному значению.
Er2Min :BOOL := FALSE; // Ошибка датчика 2 по минимальному значению.
Er3Min :BOOL := FALSE; // Ошибка датчика 3 по минимальному значению.
Er1Dif :BOOL := FALSE; // Ошибка датчика 1 по рассогласованию входов.
Er2Dif :BOOL := FALSE; // Ошибка датчика 2 по рассогласованию входов.
Er3Dif :BOOL := FALSE; // Ошибка датчика 3 по рассогласованию входов.
END_VAR

CONST // Константы.
STATE0_2oo3 := 0;
STATE1_1oo2 := 1;
STATE2_1oo2 := 2;
STATE3_1oo1 := 3;
STATE4_1oo2 := 4;
STATE5_1oo1 := 5;
STATE6_1oo1 := 6;
STATE7_0_ER := 7;
END_CONST

BEGIN

// Резервирование датчиков методом голосования.
//          Db2oo3
//    +----------------+
//    |     Fb2oo3     |
// ->-|In1          Out|->-
// ->-|In2        ErOut|-
// ->-|In3          Er1|-
//   -|ErIn1        Er2|-
//   -|ErIn2        Er3|-
//   -|ErIn3           |
//   -|DifMax          |
//   -|LimMax          |
//   -|LimMin          |
//   -|ValEr           |
//    +----------------+

// Ошибка датчика по максимальному значению.
Er1Max := (In1 >= LimMax);
Er2Max := (In2 >= LimMax);
Er3Max := (In3 >= LimMax);
// Ошибка датчика по минимальному значению.
Er1Min := (In1 <= LimMin);
Er2Min := (In2 <= LimMin);
Er3Min := (In3 <= LimMin);
// Ошибка датчика по рассогласованию входов.
// Рассогласование есть смысл проверять только если все три датчика исправны.
// Иначе могут возникнуть проблемы когда работаем с неисправными датчиками.
// Данное условие позволит продолжить работу на двух датчиках при большой разности показаний между ними.
// В данном случае мы не знаем кому доверять и для системы регулирования важнее продолжить работу.
// Если бы это была система противоаварийной защиты то лучше было уйти в ошибку.
IF (ErIn1=0 ) AND (ErIn2=0 ) AND (ErIn3=0 ) AND
   (Er1Max=0) AND (Er2Max=0) AND (Er3Max=0) AND
   (Er1Min=0) AND (Er2Min=0) AND (Er3Min=0) THEN
Er1Dif := (ABS(In1 - In2) >= DifMax) AND (ABS(In1 - In3) >= DifMax);
Er2Dif := (ABS(In2 - In1) >= DifMax) AND (ABS(In2 - In3) >= DifMax);
Er3Dif := (ABS(In3 - In1) >= DifMax) AND (ABS(In3 - In2) >= DifMax);
END_IF;
// Ошибка датчика.
// Данные флаги для сигнализации неисправности.
Er1 := ErIn1 OR Er1Max OR Er1Min OR Er1Dif;
Er2 := ErIn2 OR Er2Max OR Er2Min OR Er2Dif;
Er3 := ErIn3 OR Er3Max OR Er3Min OR Er3Dif;
// Значение выхода если все датчики неисправны.
// Данный флаг для перевода из автоматического режима работы в ручной.
ErOut := Er1 AND Er2 AND Er3;

IF (0=Er1) AND (0=Er2) AND (0=Er3) THEN State := 0; END_IF;
IF (0=Er1) AND (0=Er2) AND (1=Er3) THEN State := 1; END_IF;
IF (0=Er1) AND (1=Er2) AND (0=Er3) THEN State := 2; END_IF;
IF (0=Er1) AND (1=Er2) AND (1=Er3) THEN State := 3; END_IF;
IF (1=Er1) AND (0=Er2) AND (0=Er3) THEN State := 4; END_IF;
IF (1=Er1) AND (0=Er2) AND (1=Er3) THEN State := 5; END_IF;
IF (1=Er1) AND (1=Er2) AND (0=Er3) THEN State := 6; END_IF;
IF (1=Er1) AND (1=Er2) AND (1=Er3) THEN State := 7; END_IF;

// Можно все реализовать без оператора CASE.
// С оператором CASE получилось более наглядно.
// +-----+-----+-----+----------+
// | Er1 | Er2 | Er3 | State    |
// +-----+-----+-----+----------+
// |   0 |   0 |   0 | 0 - 2oo3 |
// |   0 |   0 |   1 | 1 - 1оо2 |
// |   0 |   1 |   0 | 2 - 1оо2 |
// |   0 |   1 |   1 | 3 - 1oo1 |
// |   1 |   0 |   0 | 4 - 1оо2 |
// |   1 |   0 |   1 | 5 - 1oo1 |
// |   1 |   1 |   0 | 6 - 1oo1 |
// |   1 |   1 |   1 | 7 - 0    |
// +-----+-----+-----+----------+

CASE State OF

STATE0_2oo3:
// State=0 2oo3 Самый лучший случай когда три датчика исправны.
// В этом случае выход это медианное значение из трех возможных входов.
// На данный участок кода смотреть как на сортировку входов по возрастанию.
// При этом выход это середина.
// Логика аналогична медианному фильтру FbFilterM только с фиксированной размерностью массива.
// Er1=0 Er2=0 Er3=0
IF (In1>=In2 AND In1<=In3) OR (In1>=In3 AND In1<=In2) THEN Out:=In1; END_IF;
IF (In2>=In3 AND In2<=In1) OR (In2>=In1 AND In2<=In3) THEN Out:=In2; END_IF;
IF (In3>=In2 AND In3<=In1) OR (In3>=In1 AND In3<=In2) THEN Out:=In3; END_IF;

STATE1_1oo2:
// State=1 1оо2 Один датчик неисправен, два датчика исправны.
// В этом случае выход это вход с младшим номером.
// Er1=0 Er2=0 Er3=1
Out := In1;

STATE2_1oo2:
// State=2 1оо2 Один датчик неисправен, два датчика исправны.
// В этом случае выход это вход с младшим номером.
// Er1=0 Er2=1 Er3=0
Out := In1;

STATE3_1oo1:
// State=3 1оо1 Два датчика неисправены, один датчик исправен.
// В этом случае выход это вход исправного датчика.
// Er1=0 Er2=1 Er3=1
Out := In1;

STATE4_1oo2:
// State=4 1оо2 Один датчик неисправен, два датчика исправны.
// В этом случае выход это вход с младшим номером.
// Er1=1 Er2=0 Er3=0
Out := In2;

STATE5_1oo1:
// State=5 1оо1 Два датчика неисправены, один датчик исправен.
// В этом случае выход это вход исправного датчика.
// Er1=1 Er2=0 Er3=1
Out := In2;

STATE6_1oo1:
// State=6 1оо1 Два датчика неисправены, один датчик исправен.
// В этом случае выход это вход исправного датчика.
// Er1=1 Er2=1 Er3=0
Out := In3;

STATE7_0_ER:
// State=7 "0" Все датчики неисправны.
// В зависимости от технологии уход на заранее заданное значение, например 0.
// Для перехода на последнее корректное значение перед сбоем
// при внешнем вызове Fb2oo3 вход Db2oo3.ValEr присоединить к выходу Db2oo3.Out.
// Er1=1 Er2=1 Er3=1
Out := ValEr;

ELSE // При неопределенном состоянии.
State := STATE7_0_ER;
END_CASE;

(*
VA 23-08-2025
https://www.reallab.ru/bookasutp/8-apparatnoe-rezervirovanie/8-2-rezervirovanie-plk/
Системы с голосованием.
  Основным отличительным признаком систем резервирования с голосованием является невозможность выделения в системе основных элементов и резервных,
поскольку все они равноправны, работают одновременно и выполняют одну и ту же функцию.
Выбор одного сигнала из нескольких осуществляется схемой голосования, которая в частном случае нечетного числа голосов называется мажоритарной схемой.
Системы с голосованием не требуют контроля работоспособности элементов для своего функционирования,
но используют подсистему диагностики для сокращения времени восстановления отказавших элементов.
Наличие системы диагностики снижает также вероятность накопления скрытых неисправностей, которые со временем могут явиться причиной отказа.
  Принцип работы схемы голосования рассмотрим на примере резервирования датчиков.
В такой системе вместо одного датчика используются три (например, три термопары), которые подсоединены к одному модулю ввода.
В схему голосования поступают, соответственно, три значения измеряемой величины (например, три значения температуры ),
из которых необходимо выбрать одно.
  Значения температуры располагаются в порядке возрастания: , а на выход схемы голосования поступает значение,
расположенное между двумя крайними (но не среднее арифметическое!).
Например, если в результате измерения получены значения (0,12; 39,5; 39,4)°С, то используется только значение 39,4, остальные игнорируются.
  Резервирование элементов с дискретными сигналами выполняется аналогично рассмотренному выше.
Поскольку значениями дискретных сигналов являются логические "0" или "1", то в результате мажоритарного голосования выбирается то значение,
которое принимают большинство сигналов. Например, при логических сигналах А="1", B="1", C="0" результатом голосования будет значение Y="1".
Блок мажоритарного голосования реализует логическую функцию Y = AB + BC + CA.
Очевидно, что для работы мажоритарной схемы число "голосов" должно быть нечетным.
Однако в системах безопасности возможно применение любого числа "голосов".
  Вместо недостающего голоса используется условие, что система считается работоспособной, если отказ является безопасным.
Это позволяет использовать системы, в которых выбирается один голос из двух и такие системы по стандарту МЭК 61508 [МЭК] обозначаются как 1oo2 (1 Out Of 2).
Используются также системы 2оо2 - (два голоса из двух), 2оо3 (два голоса из трех), 2оо4 (два голоса из четырех), 3 oo4 (три голоса из четырех).
Нерезервированные системы обозначаются как 1оо1.
Если в резервированной системе имеется развитая подсистема диагностики неисправностей, то к обозначению добавляется буква "D", например, 1oo2D.
  Примером системы с голосованием вида 1oo2 может служить система охранной сигнализации двери,
в которой используются два датчика А и В с целью взаимного резервирования (рис. 8.1, б).
При отказе одного из датчиков (например, датчика B, когда вместо А=1, В=1 получаем А=1, В=0) система,
пользуясь правилом большинства голосов, не может принять решение.
Однако, если учесть, что ложное срабатывание охранной системы не приводит к опасной ситуации,
а несрабатывание системы при наличии нарушителя является опасным отказом, очевидно, схема голосования должна считать,
что достаточно одного голоса из двух, чтобы принять решение о подаче аварийного сигнала.
Если сигналом срабатывания сигнализации является логическое значение "1",
а сигналом отсутствия нарушителя является значение "0", то блок голосования реализует логическую функцию Y = A + B.
Если входными данными для голосования являются два аналоговых сигнала,
то пользователь при программировании должен установить, какой сигнал из двух должен быть выбран системой в случае их несовпадения.
Такой подход возможен только в системах безопасности.
  Противоположная ситуация используется при голосовании вида 2oo2.
Примером может быть система контроля герметичности люка при погружении подводной лодки.
Если люк имеет два датчика, то сигнал готовности к погружению может появиться
только при наличии подтверждения ( A="1", B="1") от обоих датчиков одновременно (двух из двух).
Выход из строя одного датчика не должен позволить системе выработать сигнал готовности к погружению,
чтобы опасная ситуация не возникла. Такой блок реализует логическую функцию Y = AB.
Несмотря на высокую эффективность схем голосования с четным числом голосов, они имеют недостаток,
состоящий в возможности ложного срабатывания.
Хотя этот тип отказов и не является опасным, в некоторых случаях он приводит к значительному материальному ущербу.
Для исключения ложного срабатывания можно использовать более дорогие системы с нечетным количеством голосов,
которые снижают вероятность отказов обоих типов.
  Выбор наилучшей системы осуществляется на основании результатов экономических расчетов.
При отказе одного из элементов резервированной системы безопасности 2oo3 ее уровень безопасности понижается
и она может начать функционировать как система 1оо2.
Если замена неисправного элемента не произведена и произошел второй отказ,
то система переходит в режим без резервирования 1oo1, однако в этом режиме система не может находиться долго по требованиям безопасности.
Очередность перехода от одной схемы резервирования к другой называется схемой деградации.
Система безопасности 2оо3 может иметь второй вариант схемы деградации:
2oo3 - 2oo2 - 1oo1 - 0.
Здесь "0" обозначает состояние, когда система перестает функционировать (останавливается).
  Перед остановкой система должна перевести все свои выходы в безопасные состояния.
Понятие безопасного состояния для каждой системы определяется при ее проектировании.
Например, для систем аварийного отключения безопасными являются обесточенные состояния исполнительных механизмов,
а для систем автоматического пожаротушения или аварийной вентиляции - наоборот, состояния, при которых на исполнительные устройства подана энергия.
  Схемы голосования широко используются в системах противоаварийной защиты и сигнализации,
где они имеют большое разнообразие.
В системах же, не связанных с безопасностью, обычно нельзя применить иные схемы голосования,
кроме 2oo3, которые являются достаточно дорогими.
Однако их уникальным свойством является непрерывность функционирования во время перехода на резерв
и это свойство является определяющим при принятии решения о выборе метода резервирования.
*)

// @COPYLEFT ALL WRONGS RESERVED :)
// Author: VA
// Contacts: DIY.PLC.314@gmail.com
// Date start LIB_PLC: 2014
// License: GNU GPL-2.0-or-later
// https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
// https://www.youtube.com/watch?v=n1F_MfLRlX0
// https://www.youtube.com/@DIY_PLC
// https://github.com/DIYPLC/LIB_PLC
// https://oshwlab.com/diy.plc.314/PLC_HW1_SW1
// https://3dtoday.ru/3d-models/mechanical-parts/body/korpus-na-din-reiku
// https://t.me/DIY_PLC

END_FUNCTION_BLOCK
